(function(){"use strict";const te="ENTRIES",q="KEYS",B="VALUES";class M{constructor(e,t){const s=e._tree,i=Array.from(s.keys());this.set=e,this._type=t,this._path=i.length>0?[{node:s,keys:i}]:[]}next(){const e=this.dive();return this.backtrack(),e}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:e,keys:t}=F(this._path);if(F(t)==="")return{done:!1,value:this.result()};const s=e.get(F(t));return this._path.push({node:s,keys:Array.from(s.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const e=F(this._path).keys;e.pop(),!(e.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:e})=>F(e)).filter(e=>e!=="").join("")}value(){return F(this._path).node.get("")}result(){switch(this._type){case B:return this.value();case q:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const F=n=>n[n.length-1],se=(n,e,t)=>{const s=new Map;if(e===void 0)return s;const i=e.length+1,o=i+t,c=new Uint8Array(o*i).fill(t+1);for(let r=0;r<i;++r)c[r]=r;for(let r=1;r<o;++r)c[r*i]=r;return J(n,e,t,s,c,1,i,""),s},J=(n,e,t,s,i,o,c,r)=>{const d=o*c;e:for(const u of n.keys())if(u===""){const a=i[d-1];a<=t&&s.set(r,[n.get(u),a])}else{let a=o;for(let h=0;h<u.length;++h,++a){const l=u[h],f=c*a,_=f-c;let g=i[f];const m=Math.max(0,a-t-1),p=Math.min(c-1,a+t);for(let w=m;w<p;++w){const W=l!==e[w],P=i[_+w]+ +W,L=i[_+w+1]+1,I=i[f+w]+1,v=i[f+w+1]=Math.min(P,L,I);v<g&&(g=v)}if(g>t)continue e}J(n.get(u),e,t,s,i,a,c,r+u)}};class y{constructor(e=new Map,t=""){this._size=void 0,this._tree=e,this._prefix=t}atPrefix(e){if(!e.startsWith(this._prefix))throw new Error("Mismatched prefix");const[t,s]=S(this._tree,e.slice(this._prefix.length));if(t===void 0){const[i,o]=k(s);for(const c of i.keys())if(c!==""&&c.startsWith(o)){const r=new Map;return r.set(c.slice(o.length),i.get(c)),new y(r,e)}}return new y(t,e)}clear(){this._size=void 0,this._tree.clear()}delete(e){return this._size=void 0,ne(this._tree,e)}entries(){return new M(this,te)}forEach(e){for(const[t,s]of this)e(t,s,this)}fuzzyGet(e,t){return se(this._tree,e,t)}get(e){const t=C(this._tree,e);return t!==void 0?t.get(""):void 0}has(e){const t=C(this._tree,e);return t!==void 0&&t.has("")}keys(){return new M(this,q)}set(e,t){if(typeof e!="string")throw new Error("key must be a string");return this._size=void 0,T(this._tree,e).set("",t),this}get size(){if(this._size)return this._size;this._size=0;const e=this.entries();for(;!e.next().done;)this._size+=1;return this._size}update(e,t){if(typeof e!="string")throw new Error("key must be a string");this._size=void 0;const s=T(this._tree,e);return s.set("",t(s.get(""))),this}fetch(e,t){if(typeof e!="string")throw new Error("key must be a string");this._size=void 0;const s=T(this._tree,e);let i=s.get("");return i===void 0&&s.set("",i=t()),i}values(){return new M(this,B)}[Symbol.iterator](){return this.entries()}static from(e){const t=new y;for(const[s,i]of e)t.set(s,i);return t}static fromObject(e){return y.from(Object.entries(e))}}const S=(n,e,t=[])=>{if(e.length===0||n==null)return[n,t];for(const s of n.keys())if(s!==""&&e.startsWith(s))return t.push([n,s]),S(n.get(s),e.slice(s.length),t);return t.push([n,e]),S(void 0,"",t)},C=(n,e)=>{if(e.length===0||n==null)return n;for(const t of n.keys())if(t!==""&&e.startsWith(t))return C(n.get(t),e.slice(t.length))},T=(n,e)=>{const t=e.length;e:for(let s=0;n&&s<t;){for(const o of n.keys())if(o!==""&&e[s]===o[0]){const c=Math.min(t-s,o.length);let r=1;for(;r<c&&e[s+r]===o[r];)++r;const d=n.get(o);if(r===o.length)n=d;else{const u=new Map;u.set(o.slice(r),d),n.set(e.slice(s,s+r),u),n.delete(o),n=u}s+=r;continue e}const i=new Map;return n.set(e.slice(s),i),i}return n},ne=(n,e)=>{const[t,s]=S(n,e);if(t!==void 0){if(t.delete(""),t.size===0)$(s);else if(t.size===1){const[i,o]=t.entries().next().value;Q(s,i,o)}}},$=n=>{if(n.length===0)return;const[e,t]=k(n);if(e.delete(t),e.size===0)$(n.slice(0,-1));else if(e.size===1){const[s,i]=e.entries().next().value;s!==""&&Q(n.slice(0,-1),s,i)}},Q=(n,e,t)=>{if(n.length===0)return;const[s,i]=k(n);s.set(i+e,t),s.delete(i)},k=n=>n[n.length-1],E="or",U="and",ie="and_not";class x{constructor(e){if(e?.fields==null)throw new Error('MiniSearch: option "fields" must be provided');const t=e.autoVacuum==null||e.autoVacuum===!0?D:e.autoVacuum;this._options={...O,...e,autoVacuum:t,searchOptions:{...K,...e.searchOptions||{}},autoSuggestOptions:{...de,...e.autoSuggestOptions||{}}},this._index=new y,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=j,this.addFields(this._options.fields)}add(e){const{extractField:t,stringifyField:s,tokenize:i,processTerm:o,fields:c,idField:r}=this._options,d=t(e,r);if(d==null)throw new Error(`MiniSearch: document does not have ID field "${r}"`);if(this._idToShortId.has(d))throw new Error(`MiniSearch: duplicate ID ${d}`);const u=this.addDocumentId(d);this.saveStoredFields(u,e);for(const a of c){const h=t(e,a);if(h==null)continue;const l=i(s(h,a),a),f=this._fieldIds[a],_=new Set(l).size;this.addFieldLength(u,f,this._documentCount-1,_);for(const g of l){const m=o(g,a);if(Array.isArray(m))for(const p of m)this.addTerm(f,u,p);else m&&this.addTerm(f,u,m)}}}addAll(e){for(const t of e)this.add(t)}addAllAsync(e,t={}){const{chunkSize:s=10}=t,i={chunk:[],promise:Promise.resolve()},{chunk:o,promise:c}=e.reduce(({chunk:r,promise:d},u,a)=>(r.push(u),(a+1)%s===0?{chunk:[],promise:d.then(()=>new Promise(h=>setTimeout(h,0))).then(()=>this.addAll(r))}:{chunk:r,promise:d}),i);return c.then(()=>this.addAll(o))}remove(e){const{tokenize:t,processTerm:s,extractField:i,stringifyField:o,fields:c,idField:r}=this._options,d=i(e,r);if(d==null)throw new Error(`MiniSearch: document does not have ID field "${r}"`);const u=this._idToShortId.get(d);if(u==null)throw new Error(`MiniSearch: cannot remove document with ID ${d}: it is not in the index`);for(const a of c){const h=i(e,a);if(h==null)continue;const l=t(o(h,a),a),f=this._fieldIds[a],_=new Set(l).size;this.removeFieldLength(u,f,this._documentCount,_);for(const g of l){const m=s(g,a);if(Array.isArray(m))for(const p of m)this.removeTerm(f,u,p);else m&&this.removeTerm(f,u,m)}}this._storedFields.delete(u),this._documentIds.delete(u),this._idToShortId.delete(d),this._fieldLength.delete(u),this._documentCount-=1}removeAll(e){if(e)for(const t of e)this.remove(t);else{if(arguments.length>0)throw new Error("Expected documents to be present. Omit the argument to remove all documents.");this._index=new y,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldLength=new Map,this._avgFieldLength=[],this._storedFields=new Map,this._nextId=0}}discard(e){const t=this._idToShortId.get(e);if(t==null)throw new Error(`MiniSearch: cannot discard document with ID ${e}: it is not in the index`);this._idToShortId.delete(e),this._documentIds.delete(t),this._storedFields.delete(t),(this._fieldLength.get(t)||[]).forEach((s,i)=>{this.removeFieldLength(t,i,this._documentCount,s)}),this._fieldLength.delete(t),this._documentCount-=1,this._dirtCount+=1,this.maybeAutoVacuum()}maybeAutoVacuum(){if(this._options.autoVacuum===!1)return;const{minDirtFactor:e,minDirtCount:t,batchSize:s,batchWait:i}=this._options.autoVacuum;this.conditionalVacuum({batchSize:s,batchWait:i},{minDirtCount:t,minDirtFactor:e})}discardAll(e){const t=this._options.autoVacuum;try{this._options.autoVacuum=!1;for(const s of e)this.discard(s)}finally{this._options.autoVacuum=t}this.maybeAutoVacuum()}replace(e){const{idField:t,extractField:s}=this._options,i=s(e,t);this.discard(i),this.add(e)}vacuum(e={}){return this.conditionalVacuum(e)}conditionalVacuum(e,t){return this._currentVacuum?(this._enqueuedVacuumConditions=this._enqueuedVacuumConditions&&t,this._enqueuedVacuum!=null?this._enqueuedVacuum:(this._enqueuedVacuum=this._currentVacuum.then(()=>{const s=this._enqueuedVacuumConditions;return this._enqueuedVacuumConditions=j,this.performVacuuming(e,s)}),this._enqueuedVacuum)):this.vacuumConditionsMet(t)===!1?Promise.resolve():(this._currentVacuum=this.performVacuuming(e),this._currentVacuum)}async performVacuuming(e,t){const s=this._dirtCount;if(this.vacuumConditionsMet(t)){const i=e.batchSize||A.batchSize,o=e.batchWait||A.batchWait;let c=1;for(const[r,d]of this._index){for(const[u,a]of d)for(const[h]of a)this._documentIds.has(h)||(a.size<=1?d.delete(u):a.delete(h));this._index.get(r).size===0&&this._index.delete(r),c%i===0&&await new Promise(u=>setTimeout(u,o)),c+=1}this._dirtCount-=s}await null,this._currentVacuum=this._enqueuedVacuum,this._enqueuedVacuum=null}vacuumConditionsMet(e){if(e==null)return!0;let{minDirtCount:t,minDirtFactor:s}=e;return t=t||D.minDirtCount,s=s||D.minDirtFactor,this.dirtCount>=t&&this.dirtFactor>=s}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}has(e){return this._idToShortId.has(e)}getStoredFields(e){const t=this._idToShortId.get(e);if(t!=null)return this._storedFields.get(t)}search(e,t={}){const{searchOptions:s}=this._options,i={...s,...t},o=this.executeQuery(e,t),c=[];for(const[r,{score:d,terms:u,match:a}]of o){const h=u.length||1,l={id:this._documentIds.get(r),score:d*h,terms:Object.keys(a),queryTerms:u,match:a};Object.assign(l,this._storedFields.get(r)),(i.filter==null||i.filter(l))&&c.push(l)}return e===x.wildcard&&i.boostDocument==null||c.sort(Y),c}autoSuggest(e,t={}){t={...this._options.autoSuggestOptions,...t};const s=new Map;for(const{score:o,terms:c}of this.search(e,t)){const r=c.join(" "),d=s.get(r);d!=null?(d.score+=o,d.count+=1):s.set(r,{score:o,terms:c,count:1})}const i=[];for(const[o,{score:c,terms:r,count:d}]of s)i.push({suggestion:o,terms:r,score:c/d});return i.sort(Y),i}get documentCount(){return this._documentCount}get termCount(){return this._index.size}static loadJSON(e,t){if(t==null)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJS(JSON.parse(e),t)}static async loadJSONAsync(e,t){if(t==null)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJSAsync(JSON.parse(e),t)}static getDefault(e){if(O.hasOwnProperty(e))return V(O,e);throw new Error(`MiniSearch: unknown option "${e}"`)}static loadJS(e,t){const{index:s,documentIds:i,fieldLength:o,storedFields:c,serializationVersion:r}=e,d=this.instantiateMiniSearch(e,t);d._documentIds=z(i),d._fieldLength=z(o),d._storedFields=z(c);for(const[u,a]of d._documentIds)d._idToShortId.set(a,u);for(const[u,a]of s){const h=new Map;for(const l of Object.keys(a)){let f=a[l];r===1&&(f=f.ds),h.set(parseInt(l,10),z(f))}d._index.set(u,h)}return d}static async loadJSAsync(e,t){const{index:s,documentIds:i,fieldLength:o,storedFields:c,serializationVersion:r}=e,d=this.instantiateMiniSearch(e,t);d._documentIds=await b(i),d._fieldLength=await b(o),d._storedFields=await b(c);for(const[a,h]of d._documentIds)d._idToShortId.set(h,a);let u=0;for(const[a,h]of s){const l=new Map;for(const f of Object.keys(h)){let _=h[f];r===1&&(_=_.ds),l.set(parseInt(f,10),await b(_))}++u%1e3===0&&await Z(0),d._index.set(a,l)}return d}static instantiateMiniSearch(e,t){const{documentCount:s,nextId:i,fieldIds:o,averageFieldLength:c,dirtCount:r,serializationVersion:d}=e;if(d!==1&&d!==2)throw new Error("MiniSearch: cannot deserialize an index created with an incompatible version");const u=new x(t);return u._documentCount=s,u._nextId=i,u._idToShortId=new Map,u._fieldIds=o,u._avgFieldLength=c,u._dirtCount=r||0,u._index=new y,u}executeQuery(e,t={}){if(e===x.wildcard)return this.executeWildcardQuery(t);if(typeof e!="string"){const l={...t,...e,queries:void 0},f=e.queries.map(_=>this.executeQuery(_,l));return this.combineResults(f,l.combineWith)}const{tokenize:s,processTerm:i,searchOptions:o}=this._options,c={tokenize:s,processTerm:i,...o,...t},{tokenize:r,processTerm:d}=c,h=r(e).flatMap(l=>d(l)).filter(l=>!!l).map(ue(c)).map(l=>this.executeQuerySpec(l,c));return this.combineResults(h,c.combineWith)}executeQuerySpec(e,t){const s={...this._options.searchOptions,...t},i=(s.fields||this._options.fields).reduce((g,m)=>({...g,[m]:V(s.boost,m)||1}),{}),{boostDocument:o,weights:c,maxFuzzy:r,bm25:d}=s,{fuzzy:u,prefix:a}={...K.weights,...c},h=this._index.get(e.term),l=this.termResults(e.term,e.term,1,e.termBoost,h,i,o,d);let f,_;if(e.prefix&&(f=this._index.atPrefix(e.term)),e.fuzzy){const g=e.fuzzy===!0?.2:e.fuzzy,m=g<1?Math.min(r,Math.round(e.term.length*g)):g;m&&(_=this._index.fuzzyGet(e.term,m))}if(f)for(const[g,m]of f){const p=g.length-e.term.length;if(!p)continue;_?.delete(g);const w=a*g.length/(g.length+.3*p);this.termResults(e.term,g,w,e.termBoost,m,i,o,d,l)}if(_)for(const g of _.keys()){const[m,p]=_.get(g);if(!p)continue;const w=u*g.length/(g.length+p);this.termResults(e.term,g,w,e.termBoost,m,i,o,d,l)}return l}executeWildcardQuery(e){const t=new Map,s={...this._options.searchOptions,...e};for(const[i,o]of this._documentIds){const c=s.boostDocument?s.boostDocument(o,"",this._storedFields.get(i)):1;t.set(i,{score:c,terms:[],match:{}})}return t}combineResults(e,t=E){if(e.length===0)return new Map;const s=t.toLowerCase(),i=oe[s];if(!i)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(i)||new Map}toJSON(){const e=[];for(const[t,s]of this._index){const i={};for(const[o,c]of s)i[o]=Object.fromEntries(c);e.push([t,i])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:e,serializationVersion:2}}termResults(e,t,s,i,o,c,r,d,u=new Map){if(o==null)return u;for(const a of Object.keys(c)){const h=c[a],l=this._fieldIds[a],f=o.get(l);if(f==null)continue;let _=f.size;const g=this._avgFieldLength[l];for(const m of f.keys()){if(!this._documentIds.has(m)){this.removeTerm(l,m,t),_-=1;continue}const p=r?r(this._documentIds.get(m),t,this._storedFields.get(m)):1;if(!p)continue;const w=f.get(m),W=this._fieldLength.get(m)[l],P=ce(w,_,this._documentCount,W,g,d),L=s*i*h*p*P,I=u.get(m);if(I){I.score+=L,ae(I.terms,e);const v=V(I.match,t);v?v.push(a):I.match[t]=[a]}else u.set(m,{score:L,terms:[e],match:{[t]:[a]}})}}return u}addTerm(e,t,s){const i=this._index.fetch(s,H);let o=i.get(e);if(o==null)o=new Map,o.set(t,1),i.set(e,o);else{const c=o.get(t);o.set(t,(c||0)+1)}}removeTerm(e,t,s){if(!this._index.has(s)){this.warnDocumentChanged(t,e,s);return}const i=this._index.fetch(s,H),o=i.get(e);o==null||o.get(t)==null?this.warnDocumentChanged(t,e,s):o.get(t)<=1?o.size<=1?i.delete(e):o.delete(t):o.set(t,o.get(t)-1),this._index.get(s).size===0&&this._index.delete(s)}warnDocumentChanged(e,t,s){for(const i of Object.keys(this._fieldIds))if(this._fieldIds[i]===t){this._options.logger("warn",`MiniSearch: document with ID ${this._documentIds.get(e)} has changed before removal: term "${s}" was not present in field "${i}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}}addDocumentId(e){const t=this._nextId;return this._idToShortId.set(e,t),this._documentIds.set(t,e),this._documentCount+=1,this._nextId+=1,t}addFields(e){for(let t=0;t<e.length;t++)this._fieldIds[e[t]]=t}addFieldLength(e,t,s,i){let o=this._fieldLength.get(e);o==null&&this._fieldLength.set(e,o=[]),o[t]=i;const r=(this._avgFieldLength[t]||0)*s+i;this._avgFieldLength[t]=r/(s+1)}removeFieldLength(e,t,s,i){if(s===1){this._avgFieldLength[t]=0;return}const o=this._avgFieldLength[t]*s-i;this._avgFieldLength[t]=o/(s-1)}saveStoredFields(e,t){const{storeFields:s,extractField:i}=this._options;if(s==null||s.length===0)return;let o=this._storedFields.get(e);o==null&&this._storedFields.set(e,o={});for(const c of s){const r=i(t,c);r!==void 0&&(o[c]=r)}}}x.wildcard=Symbol("*");const V=(n,e)=>Object.prototype.hasOwnProperty.call(n,e)?n[e]:void 0,oe={[E]:(n,e)=>{for(const t of e.keys()){const s=n.get(t);if(s==null)n.set(t,e.get(t));else{const{score:i,terms:o,match:c}=e.get(t);s.score=s.score+i,s.match=Object.assign(s.match,c),G(s.terms,o)}}return n},[U]:(n,e)=>{const t=new Map;for(const s of e.keys()){const i=n.get(s);if(i==null)continue;const{score:o,terms:c,match:r}=e.get(s);G(i.terms,c),t.set(s,{score:i.score+o,terms:i.terms,match:Object.assign(i.match,r)})}return t},[ie]:(n,e)=>{for(const t of e.keys())n.delete(t);return n}},re={k:1.2,b:.7,d:.5},ce=(n,e,t,s,i,o)=>{const{k:c,b:r,d}=o;return Math.log(1+(t-e+.5)/(e+.5))*(d+n*(c+1)/(n+c*(1-r+r*s/i)))},ue=n=>(e,t,s)=>{const i=typeof n.fuzzy=="function"?n.fuzzy(e,t,s):n.fuzzy||!1,o=typeof n.prefix=="function"?n.prefix(e,t,s):n.prefix===!0,c=typeof n.boostTerm=="function"?n.boostTerm(e,t,s):1;return{term:e,fuzzy:i,prefix:o,termBoost:c}},O={idField:"id",extractField:(n,e)=>n[e],stringifyField:(n,e)=>n.toString(),tokenize:n=>n.split(le),processTerm:n=>n.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(n,e)=>{typeof console?.[n]=="function"&&console[n](e)},autoVacuum:!0},K={combineWith:E,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:re},de={combineWith:U,prefix:(n,e,t)=>e===t.length-1},A={batchSize:1e3,batchWait:10},j={minDirtFactor:.1,minDirtCount:20},D={...A,...j},ae=(n,e)=>{n.includes(e)||n.push(e)},G=(n,e)=>{for(const t of e)n.includes(t)||n.push(t)},Y=({score:n},{score:e})=>e-n,H=()=>new Map,z=n=>{const e=new Map;for(const t of Object.keys(n))e.set(parseInt(t,10),n[t]);return e},b=async n=>{const e=new Map;let t=0;for(const s of Object.keys(n))e.set(parseInt(s,10),n[s]),++t%1e3===0&&await Z(0);return e},Z=n=>new Promise(e=>setTimeout(e,n)),le=/[\n\r\p{Z}\p{P}]+/u;function he(n,e){return!e||!n.classReq?!0:n.classReq===e}function fe(n,e){return n.level<=e}function me(n,e){switch(e){case"level":return n.level;case"powderSlots":return n.powderSlots;default:return n.numericIndex[e]??0}}function ge(n,e){return e.length===0||e.includes(n.category)}function X(n,e){return e.length===0?!0:n?e.includes(n):!1}function _e(n,e){for(const[t,s]of Object.entries(e.numericRanges)){if(!s)continue;const i=me(n,t);if(typeof s.min=="number"&&i<s.min||typeof s.max=="number"&&i>s.max)return!1}return!0}function pe(n,e){if(e.excludeRestricted&&(n.restricted||n.deprecated)||e.onlyWearableAtLevel!==null&&!fe(n,e.onlyWearableAtLevel))return!1;if(e.onlyClassCompatible){const t=e.classReqs[0]??null;if(!he(n,t))return!1}return!0}function we(n,e){return e.length===0?!0:n.majorIds.length===0?!1:e.every(t=>n.majorIds.includes(t))}function ye(n,e){return!(!ge(n,e.categories)||!X(n.type,e.types)||!X(n.tier,e.tiers)||e.classReqs.length>0&&(n.classReq===null||!e.classReqs.includes(n.classReq))||!we(n,e.majorIds)||!_e(n,e)||!pe(n,e))}function ee(n,e){switch(e){case"level":return n.level;case"baseDps":return n.roughScoreFields.baseDps;case"ehpProxy":return n.roughScoreFields.ehpProxy;case"offenseScore":return n.roughScoreFields.offense;case"skillPointTotal":return n.roughScoreFields.skillPointTotal;default:return 0}}function Ie(n,e,t){const s=e.trim().toLowerCase();if(!s)return 0;const i=n.displayName.toLowerCase();return i===s?t+5e3:i.startsWith(s)?t+3e3:i.includes(s)?t+1200:n.searchText.includes(s)?t+300:t}function Fe(n,e,t){const s=t.sortDescending?-1:1;if(t.sort==="relevance"){if(n.relevance!==e.relevance)return(n.relevance>e.relevance?-1:1)*(t.sortDescending?1:-1)}else{const i=ee(n.item,t.sort),o=ee(e.item,t.sort);if(i!==o)return i<o?-s:s}return n.item.level!==e.item.level?n.item.level<e.item.level?1:-1:n.item.displayName.localeCompare(e.item.displayName)}function xe(){return{categories:{},types:{},tiers:{},majorIds:{}}}function N(n,e){e&&(n[e]=(n[e]??0)+1)}class ve{miniSearch;itemsById;allItems;constructor(e){this.allItems=e,this.itemsById=new Map(e.map(t=>[t.id,t])),this.miniSearch=new x({fields:["displayName","searchText","majorIdsText"],storeFields:["id"],idField:"id",searchOptions:{boost:{displayName:6,searchText:2,majorIdsText:2},prefix:!0,fuzzy:.2,combineWith:"OR"}}),this.miniSearch.addAll(e.map(t=>({id:t.id,displayName:t.displayName,searchText:t.searchText,majorIdsText:t.majorIdsText})))}search(e){const t=e.text.trim(),s=t?this.miniSearch.search(t,{prefix:!0,fuzzy:.2,boost:{displayName:8,searchText:2,majorIdsText:2}}):[],i=new Map;for(const u of s){const a=this.itemsById.get(u.id);a&&i.set(a.id,Ie(a,t,Number(u.score??0)))}const o=t?[...this.allItems]:this.allItems,c=[],r=xe();for(const u of o){const a=i.get(u.id)??0;if(!(t&&a===0&&!u.searchText.includes(t.toLowerCase()))&&ye(u,e)){c.push({item:u,relevance:a}),r.categories[u.category]=(r.categories[u.category]??0)+1,N(r.types,u.type),N(r.tiers,u.tier);for(const h of u.majorIds)N(r.majorIds,h)}}c.sort((u,a)=>Fe(u,a,e));const d=c.map(({item:u,relevance:a})=>({id:u.id,relevance:a}));return{total:d.length,rows:d,facetCounts:r}}}let R=null;self.onmessage=n=>{const e=n.data;try{if(e.type==="init"){R=new ve(e.items);const i={type:"ready",requestId:e.requestId};self.postMessage(i);return}if(!R)throw new Error("Search engine is not initialized");const t=R.search(e.state),s={type:"result",requestId:e.requestId,result:t};self.postMessage(s)}catch(t){const s={type:"error",requestId:e.requestId,message:t instanceof Error?t.message:"Unknown search worker error"};self.postMessage(s)}}})();
